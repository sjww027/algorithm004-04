# NOTE
本周学习了两个数据结构，分别是Trie 树和 并查询， 这两种结构比较"冷门"， 我自己在工作中并没有实际使用过。

Trie 树解决了"单词"场景中存储空间和查询速度的问题， 通过"合并"相同的前缀来压缩空间， 通过每个字母的哈希索引来解决查询的速度。
但Trie 树也有局限性， 我认为它适用于单词数量很大而且重复性很高的场景。 由于它需要一个个字母来遍历，所以针对单词长度很长， 前缀重复性不高的场景，
Trie 并不合适。 
从学习的角度来说 ： Trie 的实现算法并不复杂，并不需要什么递推和寻找重复性。 但它的存储结构比较"反人类"，它是通过嵌套哈希来实现， 看起来很不直观。
比如： 单词"apple" 用哈希来实现就是:  {a:{p:{p:{l:{e:{},#:#}}}}}}. 看起来非常'恶心'。

并查询 我认为更多的是提供了除"dfs" 和 "bfs" 以外的一种"解题思路"， 是的， 从我自己的理解来看，这仅仅是一种解题思路， 它的算法复杂度和时间复杂度
并无优势， 并且在某种程度上更难理解。 为了解决这个学习上的问题，我总结了一个例子， 方便自己理解。

举个例子：一个长度为6 的parent 数据是 : [0,1,2,3,4,5] 
        它的下标刚好也是0-5， 在这个状态下 每个下标对于的"父亲" 就是自己， 就好像每个元素都是一个"孤岛"， 这个时候，孤岛有5个。
        当改变下标对应的值（更准确来说是做union(2,3)的操作）， 比如讲下标2的值改为3， 那么对应的状态就是:  [0,1,3,3,4,5] ， 
        这就表示下标为"2" 的父亲变成"3"，这个时候由于 2->3,所以孤岛变成了4个。 
        总的来说， 数组的下标所对应的值就是它的父亲，由于数组下标是"天然存在" 的， 所以也就无需额外的存储空间来保存"子->父" 的单向关系。


  

