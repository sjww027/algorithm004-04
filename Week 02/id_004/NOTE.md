# NOTE

这周的课程内容开始变多, 题目的深度与广度也开始加强, 即便提交了作业, 但后面还是非常需要反复练习.

首先是哈希表与集合, 通过key-value 的方式解决链表查询效率的问题, 但也是用空间换时间.
同样的思路, 二叉树的引入, 开始使用二维空间来解决查找效率的问题, 将O(N) 的时间复杂度降到 O(logN).

我觉得引入了树的结构后, 不仅引入了额外的空间复杂度, 而且还引入了"递归" 这种"理解上的复杂度".
我们一般写循环, 都是迭代式的, 一个"for, while" 就搞定了, 但递归就像另外一种写"循环" 的方式. 这种方式不好理解.但非常强大.
面对像"树"这种本身就"递归定义" 的数据接口, 就能大派用场.

"递归" 就像一个工具, 老师提供了一个基本的模板方便我们理解与练习. 后面的引入的"分治" 与" 回溯" 更多的是对这种工具的细化或者
是更高级的使用.

从老师的模板上做对比可以看出, "分治": 主要的关注点是问题的分解策略. "回溯": 的主要关注点是在处理数据的过程中需要对之前产生的"中间"
结果"进行判断来决定后续的走向. 
这两种做法的时间复杂度可能会非常高, 后续会引入"剪枝" 或者"DP" 来解决. 
  
最后总结一下自己的做题心得: 
在做242 题目的时候,自己做的代码非常挫,直接使用了Java 的HashMap, 而且处理value 更新的时候非常啰嗦, 
但按照老师的思路, 还是能通过了测试.我发现原来的解题思路相当狭隘, 以为哈希表一定是java 中的HashMap, 
但其实数组的下标也是一个"天然的key", 只要key 的取值范围在常数级别,就可以考虑直接使用数组来"模拟" hashMap 的操作. 
在王铮老师的"字符串"算法系列中, 也经常使用这种做法. 自己的总结是: 当发现自己写得很啰嗦, 虽然时间复杂度没问题, 也需要多参考
别人优雅的解法, 这样可以提升自己的专业度.
  





